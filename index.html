<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hand Game Online - Mobile Optimized</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <style>
        body { margin: 0; background-color: #000; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; font-family: sans-serif; }
        #container { position: relative; width: 100vw; height: 100vh; }
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; }
        video { display: none; }
    </style>
</head>
<body>

<div id="container">
    <video id="input_video" playsinline></video>
    <canvas id="output_canvas"></canvas>
</div>

<script>
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');

    let score = 0;
    let gameStarted = false;
    let cameraReady = false; 
    let startTime = 0;
    let nextStartEnabledTime = 0;
    const gameDuration = 40;
    
    // 画面サイズに基づいた動的なサイズ設定
    let circleRadius, fontSizeInsideCircle, uiBoxWidth, uiBoxHeight, uiMargin;

    let circles = [];
    let targetCount = 1;
    let randomOrder = [];

    const synth = window.speechSynthesis;
    function speak(text) {
        if (synth.speaking) synth.cancel();
        const utter = new SpeechSynthesisUtterance(text);
        utter.lang = 'ja-JP';
        synth.speak(utter);
    }

    function playBeep() {
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        oscillator.type = 'sine';
        oscillator.frequency.setValueAtTime(900, audioCtx.currentTime);
        oscillator.start();
        gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 0.1);
        oscillator.stop(audioCtx.currentTime + 0.1);
    }

    function updateCanvasSize() {
        canvasElement.width = window.innerWidth;
        canvasElement.height = window.innerHeight;
        
        // スマホ・タブレットそれぞれの画面幅に合わせてUIサイズを調整
        const minDim = Math.min(canvasElement.width, canvasElement.height);
        circleRadius = minDim * 0.08; 
        fontSizeInsideCircle = Math.floor(circleRadius * 1.2);
        uiBoxWidth = Math.min(canvasElement.width * 0.4, 200);
        uiBoxHeight = Math.min(canvasElement.height * 0.08, 60);
        uiMargin = 10;
    }
    window.addEventListener('resize', updateCanvasSize);
    updateCanvasSize();

    function generateCircles() {
        circles = [];
        targetCount = 1;
        randomOrder = Array.from({length: 10}, (_, i) => i + 1).sort(() => Math.random() - 0.5);
        
        const verticalMargin = uiBoxHeight + 40; 

        for (let i = 0; i < 10; i++) {
            let x, y;
            let isValid = false;
            let attempts = 0;
            while (!isValid && attempts < 50) {
                // 画面を10のエリアに分けて重なりを減らす
                const sectionWidth = canvasElement.width / 5;
                const sectionHeight = canvasElement.height / 2;
                const col = i % 5;
                const row = Math.floor(i / 5);

                const minX = col * sectionWidth + circleRadius;
                const maxX = (col + 1) * sectionWidth - circleRadius;
                x = Math.random() * (maxX - minX) + minX;
                
                const minY = row * sectionHeight + circleRadius + uiBoxHeight;
                const maxY = (row + 1) * sectionHeight - circleRadius - 20;
                y = Math.random() * (maxY - minY) + minY;

                // スコア・タイマーエリアとの重なり判定
                const inScoreArea = (x < uiBoxWidth + circleRadius + uiMargin && y < uiBoxHeight + circleRadius + uiMargin);
                const inTimerArea = (x > canvasElement.width - (uiBoxWidth + circleRadius + uiMargin) && y < uiBoxHeight + circleRadius + uiMargin);

                if (!inScoreArea && !inTimerArea) {
                    isValid = true;
                }
                attempts++;
            }
            circles.push({ x: x, y: y, value: randomOrder[i], hit: false });
        }
    }

    function checkCollision(hx, hy, cx, cy) {
        const dist = Math.sqrt((hx - cx) ** 2 + (hy - cy) ** 2);
        // 判定距離を円の半径+αに調整
        return dist < circleRadius + (circleRadius * 0.8);
    }

    function onResults(results) {
        cameraReady = true; 
        const currentTime = Date.now();

        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        canvasCtx.translate(canvasElement.width, 0);
        canvasCtx.scale(-1, 1);
        canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
        canvasCtx.restore();

        let timeLeft = 0;
        if (gameStarted) {
            timeLeft = Math.max(0, gameDuration - Math.floor((currentTime - startTime) / 1000));
            if (timeLeft <= 0) {
                gameStarted = false;
                nextStartEnabledTime = currentTime + 3000;
                speak(score + "点です。終了。");
            }
        }

        let hands = [];
        if (results.poseLandmarks) {
            // 手首(15, 16)と人差し指(19, 20)の中間あたりを判定に使う
            const lIdx = results.poseLandmarks[19];
            const rIdx = results.poseLandmarks[20];
            
            if(lIdx.visibility > 0.5) hands.push({ x: (1 - lIdx.x) * canvasElement.width, y: lIdx.y * canvasElement.height });
            if(rIdx.visibility > 0.5) hands.push({ x: (1 - rIdx.x) * canvasElement.width, y: rIdx.y * canvasElement.height });

            hands.forEach(h => {
                canvasCtx.beginPath();
                canvasCtx.arc(h.x, h.y, circleRadius * 0.7, 0, 2 * Math.PI);
                canvasCtx.strokeStyle = 'yellow';
                canvasCtx.lineWidth = 4;
                canvasCtx.stroke();
            });

            if (!gameStarted && currentTime > nextStartEnabledTime) {
                // スマホは画面が縦長なので、開始判定のy座標を少し甘めに設定(0.4 -> 0.5)
                if (lIdx.y < 0.5 || rIdx.y < 0.5) {
                    gameStarted = true;
                    score = 0;
                    startTime = Date.now();
                    generateCircles();
                    speak("スタート");
                }
            }
        }

        if (gameStarted) {
            let allHit = true;
            circles.forEach(c => {
                if (!c.hit) {
                    allHit = false;
                    if (c.value === targetCount) {
                        hands.forEach(h => {
                            if (checkCollision(h.x, h.y, c.x, c.y)) {
                                c.hit = true;
                                score++;
                                targetCount++;
                                playBeep();
                            }
                        });
                    }
                    
                    canvasCtx.beginPath();
                    canvasCtx.arc(c.x, c.y, circleRadius, 0, 2 * Math.PI);
                    canvasCtx.fillStyle = 'red';
                    canvasCtx.fill();
                    
                    canvasCtx.fillStyle = 'lime';
                    canvasCtx.font = `bold ${fontSizeInsideCircle}px Arial`;
                    canvasCtx.textAlign = "center";
                    canvasCtx.textBaseline = "middle";
                    canvasCtx.fillText(c.value, c.x, c.y);
                } else {
                    canvasCtx.beginPath();
                    canvasCtx.arc(c.x, c.y, circleRadius, 0, 2 * Math.PI);
                    canvasCtx.fillStyle = 'rgba(0, 255, 0, 0.3)'; // ヒット後は半透明の緑
                    canvasCtx.fill();
                }
            });
            if (allHit) generateCircles();
        }

        // --- UI表示 ---
        const uiFontSize = Math.floor(uiBoxHeight * 0.5);
        canvasCtx.textBaseline = "middle";
        
        // Score (左上)
        canvasCtx.fillStyle = "rgba(0, 0, 0, 0.5)";
        canvasCtx.fillRect(uiMargin, uiMargin, uiBoxWidth, uiBoxHeight);
        canvasCtx.textAlign = "center";
        canvasCtx.fillStyle = "lime";
        canvasCtx.font = `bold ${uiFontSize}px Arial`;
        canvasCtx.fillText(`Score: ${score}`, uiMargin + (uiBoxWidth/2), uiMargin + (uiBoxHeight / 2));
        
        // Time (右上)
        canvasCtx.fillStyle = "rgba(0, 0, 0, 0.5)";
        canvasCtx.fillRect(canvasElement.width - uiBoxWidth - uiMargin, uiMargin, uiBoxWidth, uiBoxHeight);
        canvasCtx.fillStyle = "white";
        canvasCtx.fillText(`Time: ${timeLeft}`, canvasElement.width - (uiBoxWidth/2) - uiMargin, uiMargin + (uiBoxHeight / 2));

        if (!gameStarted) {
            canvasCtx.textAlign = "center";
            canvasCtx.textBaseline = "middle";
            const msgFontSize = Math.floor(canvasElement.width * 0.08);
            
            if (currentTime < nextStartEnabledTime) {
                const waitSec = Math.ceil((nextStartEnabledTime - currentTime) / 1000);
                canvasCtx.font = `bold ${msgFontSize}px Arial`;
                canvasCtx.fillStyle = "orange";
                canvasCtx.fillText(`Wait... ${waitSec}`, canvasElement.width / 2, canvasElement.height / 2);
            } else {
                canvasCtx.font = `bold ${msgFontSize}px Arial`;
                canvasCtx.fillStyle = "yellow";
                canvasCtx.fillText("片手を挙げてスタート", canvasElement.width / 2, canvasElement.height / 2);
            }
        }
    }

    function drawInitialLoading() {
        if (!cameraReady) {
            canvasCtx.fillStyle = "black";
            canvasCtx.fillRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.fillStyle = "white";
            canvasCtx.font = "24px Arial";
            canvasCtx.textAlign = "center";
            canvasCtx.fillText("カメラ起動中...", canvasElement.width / 2, canvasElement.height / 2);
            requestAnimationFrame(drawInitialLoading);
        }
    }
    drawInitialLoading();

    const pose = new Pose({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}` });
    pose.setOptions({ modelComplexity: 0, smoothLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    pose.onResults(onResults);

    // スマホ向けに解像度設定を調整
    const camera = new Camera(videoElement, {
        onFrame: async () => { await pose.send({image: videoElement}); },
        width: {ideal: 640}, height: {ideal: 480}
    });
    camera.start();

    speak("カメラを起動します");
</script>
</body>
</html>